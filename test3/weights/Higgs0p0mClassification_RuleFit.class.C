// Class: ReadRuleFit
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : RuleFit::RuleFit
TMVA Release   : 4.2.0         [262656]
ROOT Release   : 5.34/14       [336398]
Creator        : uh234
Date           : Sun Feb 16 15:26:37 2014
Host           : Linux lxbuild175.cern.ch 2.6.18-308.4.1.el5 #1 SMP Wed Apr 18 16:26:27 CEST 2012 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /export/home/uh234/home/HiggsResearch/test3
Training events: 18837
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
H: "True" [Print method-specific help message]
GDTau: "-1.000000e+00" [Gradient-directed (GD) path: default fit cut-off]
GDTauPrec: "1.000000e-02" [GD path: precision of tau]
GDStep: "1.000000e-02" [GD path: step size]
GDNSteps: "10000" [GD path: number of steps]
GDErrScale: "1.020000e+00" [Stop scan when error > scale*errmin]
fEventsMin: "1.000000e-02" [Minimum fraction of events in a splittable node]
fEventsMax: "5.000000e-01" [Maximum fraction of events in a splittable node]
nTrees: "20" [Number of trees in forest.]
RuleMinDist: "1.000000e-03" [Minimum distance between rules]
MinImp: "1.000000e-03" [Minimum rule importance accepted]
Model: "modrulelinear" [Model to be used]
RuleFitModule: "rftmva" [Which RuleFit module to use]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
LinQuantile: "2.500000e-02" [Quantile of linear terms (removes outliers)]
GDPathEveFrac: "5.000000e-01" [Fraction of events used for the path search]
GDValidEveFrac: "5.000000e-01" [Fraction of events used for the validation]
ForestType: "adaboost" [Method to use for forest generation (AdaBoost or RandomForest)]
RFWorkDir: "./rulefit" [Friedman's RuleFit module (RFF): working dir]
RFNrules: "2000" [RFF: Mximum number of rules]
RFNendnodes: "4" [RFF: Average number of end nodes]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 5
cth1                          cth1                          cth1                          Variable 1                    units                             'F'    [-0.999111533165,0.999752283096]
cth2                          cth2                          cth2                          Variable 2                    units                             'F'    [-0.999997198582,0.999910354614]
phi                           phi                           phi                           Variable 3                    units                             'F'    [-3.1415014267,3.14110398293]
m12                           m12                           m12                           Variable 4                    units                             'F'    [2.26048517227,101.457084656]
m34                           m34                           m34                           Variable 5                    units                             'F'    [0.437031298876,88.3182373047]
NSpec 0


============================================================================ */

#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadRuleFit : public IClassifierReader {

 public:

   // constructor
   ReadRuleFit( std::vector<std::string>& theInputVars ) 
      : IClassifierReader(),
        fClassName( "ReadRuleFit" ),
        fNvars( 5 ),
        fIsNormalised( false )
   {      
      // the training input variables
      const char* inputVars[] = { "cth1", "cth2", "phi", "m12", "m34" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 0;
      fVmax[0] = 0;
      fVmin[1] = 0;
      fVmax[1] = 0;
      fVmin[2] = 0;
      fVmax[2] = 0;
      fVmin[3] = 0;
      fVmax[3] = 0;
      fVmin[4] = 0;
      fVmax[4] = 0;

      // initialize input variable types
      fType[0] = 'F';
      fType[1] = 'F';
      fType[2] = 'F';
      fType[3] = 'F';
      fType[4] = 'F';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadRuleFit() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the 
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   const bool fIsNormalised;
   bool IsNormalised() const { return fIsNormalised; }
   double fVmin[5];
   double fVmax[5];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[5];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   // not implemented for class: "ReadRuleFit"
};
void   ReadRuleFit::Initialize(){}
void   ReadRuleFit::Clear(){}
double ReadRuleFit::GetMvaValue__( const std::vector<double>& inputValues ) const {
   double rval=-0.1552017862;
   //
   // here follows all rules ordered in importance (most important first)
   // at the end of each line, the relative importance of the rule is given
   //
   if ((inputValues[0]<0.3334643543)&&(-0.564648211<inputValues[1])&&(inputValues[1]<0.5237419009)) rval+=0.2266188882;   // importance = 1.000
   if ((-0.4285950363<inputValues[1])) rval+=0.1688566131;   // importance = 0.677
   if ((44.77331543<inputValues[3])&&(inputValues[3]<92.37830353)&&(15.30425739<inputValues[4])) rval+=-0.1833218234;   // importance = 0.658
   if ((87.28614044<inputValues[3])&&(25.50214767<inputValues[4])&&(inputValues[4]<38.10040665)) rval+=0.1636765689;   // importance = 0.652
   if ((inputValues[0]<0.5238323212)&&(77.8388443<inputValues[3])) rval+=0.1384644347;   // importance = 0.624
   if ((0.3333078027<inputValues[1])&&(-2.600188732<inputValues[2])&&(85.73356628<inputValues[3])&&(inputValues[4]<29.65383911)) rval+=-0.1808427801;   // importance = 0.541
   if ((0.1726312488<inputValues[0])&&(-2.600188732<inputValues[2])&&(17.13199615<inputValues[4])) rval+=-0.1252720466;   // importance = 0.539
   if ((-2.600188732<inputValues[2])&&(17.13199615<inputValues[4])) rval+=-0.15319406;   // importance = 0.527
   if ((inputValues[0]<0.3334643543)&&(inputValues[1]<0.5237419009)) rval+=0.09908166554;   // importance = 0.447
   if ((inputValues[1]<0.333253324)&&(-1.290021062<inputValues[2])&&(inputValues[2]<0.7477304935)) rval+=0.1156778784;   // importance = 0.425
   if ((inputValues[3]<87.28614044)) rval+=-0.09304536109;   // importance = 0.420
   if ((0.04771501943<inputValues[0])&&(inputValues[3]<77.8388443)) rval+=-0.1218124496;   // importance = 0.414
   if ((0.1429745853<inputValues[0])&&(-0.6734885573<inputValues[1])&&(inputValues[1]<0.7142092586)) rval+=0.09818107983;   // importance = 0.405
   if ((inputValues[1]<0.3876953423)) rval+=0.09129729507;   // importance = 0.385
   if ((-2.600188732<inputValues[2])&&(85.73356628<inputValues[3])&&(inputValues[4]<29.65383911)) rval+=-0.08213298777;   // importance = 0.359
   if ((-0.4489562511<inputValues[2])) rval+=0.08000912032;   // importance = 0.358
   if ((inputValues[2]<0.1495515108)&&(87.28614044<inputValues[3])) rval+=0.08815939927;   // importance = 0.352
   if ((inputValues[1]<0.2381130457)&&(inputValues[2]<-0.4489562511)) rval+=-0.08199226866;   // importance = 0.324
   if ((0.3334643543<inputValues[0])&&(0.4483736157<inputValues[2])) rval+=-0.1010793053;   // importance = 0.310
   if ((inputValues[0]<0.3334643543)) rval+=0.07311868256;   // importance = 0.305
   if ((inputValues[0]<0.5238323212)&&(77.8388443<inputValues[3])&&(inputValues[3]<90.2264328)&&(29.22151184<inputValues[4])) rval+=0.09921946494;   // importance = 0.284
   if ((inputValues[0]<0.3332131803)&&(inputValues[1]<0.7142092586)&&(17.05367088<inputValues[4])) rval+=0.06230745024;   // importance = 0.281
   if ((inputValues[3]<58.51519775)&&(38.10040665<inputValues[4])) rval+=-0.08745780256;   // importance = 0.271
   if ((inputValues[0]<0.306288451)&&(inputValues[3]<60.74700546)&&(21.36112785<inputValues[4])) rval+=-0.09338296562;   // importance = 0.269
   if ((inputValues[2]<0.7477304935)) rval+=0.05484229145;   // importance = 0.241
   if ((0.3332131803<inputValues[0])&&(inputValues[0]<0.7138917446)&&(inputValues[1]<0.7142092586)) rval+=0.0645986182;   // importance = 0.223
   if ((inputValues[0]<0.04771501943)&&(inputValues[3]<77.8388443)) rval+=-0.06251093888;   // importance = 0.215
   if ((inputValues[0]<0.3334643543)&&(0.5237419009<inputValues[1])&&(inputValues[3]<87.1496582)) rval+=-0.08327359225;   // importance = 0.206
   if ((-0.178043887<inputValues[0])&&(inputValues[0]<0.306288451)&&(21.36112785<inputValues[4])) rval+=0.05192171385;   // importance = 0.204
   if ((inputValues[0]<0.2019845843)&&(inputValues[1]<0.768658042)&&(1.944417238<inputValues[2])) rval+=0.07226676362;   // importance = 0.199
   if ((61.26124191<inputValues[3])&&(39.48997879<inputValues[4])) rval+=-0.0710379452;   // importance = 0.191
   if ((-0.2381276488<inputValues[1])&&(44.77331543<inputValues[3])&&(inputValues[3]<60.98342133)&&(15.30425739<inputValues[4])) rval+=-0.07442370654;   // importance = 0.182
   if ((0.1495515108<inputValues[2])&&(87.28614044<inputValues[3])) rval+=0.046943436;   // importance = 0.182
   if ((-0.429651767<inputValues[0])&&(inputValues[0]<0.306288451)&&(87.03876495<inputValues[3])&&(21.36112785<inputValues[4])) rval+=0.05227728417;   // importance = 0.181
   if ((-0.1424556077<inputValues[0])&&(86.87985229<inputValues[3])) rval+=0.04072722092;   // importance = 0.175
   if ((-0.5231915712<inputValues[0])) rval+=0.06038166021;   // importance = 0.172
   if ((44.77331543<inputValues[3])) rval+=-0.07590921133;   // importance = 0.166
   if ((inputValues[0]<0.1839083284)&&(77.8388443<inputValues[3])&&(inputValues[4]<24.86301422)) rval+=0.04953405549;   // importance = 0.165
   if ((0.7142092586<inputValues[1])&&(inputValues[1]<0.8774902821)) rval+=-0.06060873935;   // importance = 0.155
   if ((38.10040665<inputValues[4])) rval+=-0.03653213808;   // importance = 0.146
   if ((inputValues[0]<0.1726312488)&&(-2.600188732<inputValues[2])&&(17.13199615<inputValues[4])) rval+=-0.02652664847;   // importance = 0.120
   if ((inputValues[0]<0.3332131803)&&(inputValues[1]<0.7142092586)&&(inputValues[2]<2.24330616)&&(17.05367088<inputValues[4])) rval+=-0.0263380515;   // importance = 0.118
   if ((0.7477304935<inputValues[2])&&(inputValues[4]<29.88056564)) rval+=-0.03230974222;   // importance = 0.116
   if ((inputValues[0]<0.3334643543)&&(0.5237419009<inputValues[1])) rval+=-0.03437221888;   // importance = 0.115
   if ((-0.429651767<inputValues[0])&&(inputValues[0]<0.306288451)&&(inputValues[3]<87.03876495)&&(21.36112785<inputValues[4])) rval+=0.03068742696;   // importance = 0.112
   if ((inputValues[0]<-0.5231915712)&&(inputValues[1]<0.768658042)&&(inputValues[2]<1.944417238)) rval+=-0.04278713895;   // importance = 0.104
   if ((inputValues[0]<0.1726312488)&&(-2.600188732<inputValues[2])&&(inputValues[2]<0.5832898021)&&(17.13199615<inputValues[4])) rval+=-0.02525480447;   // importance = 0.100
   if ((inputValues[0]<0.3334643543)&&(0.5237419009<inputValues[1])&&(87.1496582<inputValues[3])) rval+=-0.03434991871;   // importance = 0.086
   if ((inputValues[0]<0.306288451)&&(60.74700546<inputValues[3])&&(21.36112785<inputValues[4])) rval+=-0.01868030624;   // importance = 0.083
   if ((0.3334643543<inputValues[0])&&(inputValues[2]<0.4483736157)) rval+=-0.02409290105;   // importance = 0.083
   if ((inputValues[0]<0.306288451)&&(21.36112785<inputValues[4])&&(inputValues[4]<30.67877007)) rval+=-0.02097497698;   // importance = 0.080
   if ((0.3332131803<inputValues[0])&&(inputValues[0]<0.7138917446)&&(inputValues[1]<0.7142092586)&&(inputValues[2]<0.4502744079)) rval+=0.02731875716;   // importance = 0.074
   if ((0.333253324<inputValues[1])&&(inputValues[2]<0.7477304935)) rval+=0.01293699807;   // importance = 0.048
   if ((inputValues[3]<87.28614044)&&(inputValues[4]<26.95772362)) rval+=0.01791137652;   // importance = 0.044
   if ((-2.600188732<inputValues[2])&&(inputValues[3]<85.73356628)&&(inputValues[4]<29.65383911)) rval+=-0.01545853951;   // importance = 0.038
   if ((inputValues[0]<0.306288451)&&(21.36112785<inputValues[4])) rval+=-0.007818255275;   // importance = 0.035
   if ((inputValues[0]<0.3332131803)&&(inputValues[1]<0.7142092586)&&(2.24330616<inputValues[2])&&(17.05367088<inputValues[4])) rval+=0.01163961661;   // importance = 0.028
   if ((inputValues[1]<0.3333078027)&&(-2.600188732<inputValues[2])&&(85.73356628<inputValues[3])&&(inputValues[4]<29.65383911)) rval+=-0.005673788671;   // importance = 0.022
   if ((0.3332131803<inputValues[0])&&(inputValues[1]<0.7142092586)) rval+=-0.004964805439;   // importance = 0.020
   if ((-0.2924974859<inputValues[1])&&(inputValues[1]<0.2381130457)&&(inputValues[2]<-0.4489562511)) rval+=0.006583107705;   // importance = 0.019
   if ((73.11519623<inputValues[3])&&(inputValues[3]<83.92111969)&&(32.02864838<inputValues[4])&&(inputValues[4]<39.48997879)) rval+=-0.009103780784;   // importance = 0.017
   if ((44.77331543<inputValues[3])&&(inputValues[4]<15.30425739)) rval+=0.006380556219;   // importance = 0.015
   if ((inputValues[2]<1.289423108)&&(73.11519623<inputValues[3])&&(inputValues[3]<83.92111969)&&(29.03859329<inputValues[4])&&(inputValues[4]<39.48997879)) rval+=-0.007829920069;   // importance = 0.014
   if ((0.3334643543<inputValues[0])&&(0.0476375483<inputValues[1])&&(inputValues[2]<-1.047299623)) rval+=0.005574797483;   // importance = 0.011
   if ((inputValues[4]<38.10040665)) rval+=-0.001475790329;   // importance = 0.006
   if ((inputValues[0]<0.3332131803)&&(inputValues[1]<0.7142092586)&&(0.2159715742<inputValues[2])&&(inputValues[2]<0.9597398639)&&(17.05367088<inputValues[4])) rval+=0.001653650919;   // importance = 0.004
   if ((-0.7481218576<inputValues[2])&&(73.11519623<inputValues[3])&&(inputValues[3]<83.92111969)&&(29.03859329<inputValues[4])&&(inputValues[4]<39.48997879)) rval+=-0.001866989468;   // importance = 0.003
   //
   // here follows all linear terms
   // at the end of each line, the relative importance of the term is given
   //
   rval+=-0.01677143966*std::min( double(0.9121149182), std::max( double(inputValues[0]), double(-0.8409083486)));   // importance = 0.072
   rval+=0.02646876161*std::min( double(0.9494906664), std::max( double(inputValues[1]), double(-0.9413555861)));   // importance = 0.140
   rval+=0.002666912281*std::min( double(2.981077433), std::max( double(inputValues[2]), double(-2.980573654)));   // importance = 0.045
   rval+=-0.003562117774*std::min( double(93.65103149), std::max( double(inputValues[3]), double(35.23851013)));   // importance = 0.548
   rval+=-0.001548129631*std::min( double(70.11781311), std::max( double(inputValues[4]), double(9.65700531)));   // importance = 0.205
   return rval;
}
   inline double ReadRuleFit::GetMvaValue( const std::vector<double>& inputValues ) const
   {
      // classifier response value
      double retval = 0;

      // classifier response, sanity check first
      if (!IsStatusClean()) {
         std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                   << " because status is dirty" << std::endl;
         retval = 0;
      }
      else {
         if (IsNormalised()) {
            // normalise variables
            std::vector<double> iV;
            iV.reserve(inputValues.size());
            int ivar = 0;
            for (std::vector<double>::const_iterator varIt = inputValues.begin();
                 varIt != inputValues.end(); varIt++, ivar++) {
               iV.push_back(NormVariable( *varIt, fVmin[ivar], fVmax[ivar] ));
            }
            retval = GetMvaValue__( iV );
         }
         else {
            retval = GetMvaValue__( inputValues );
         }
      }

      return retval;
   }
